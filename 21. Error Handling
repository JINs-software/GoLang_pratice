[에러 반환]
에러를 처리하는 가장 기본 방식은 에러를 반환하고 알맞게 처리하는 방식
ex) ReadFile() 함수로 파일을 읽을 때 해당하는 파일이 없어 에러가 발생했다고 할 때,
    프로그램이 강제 종료되는 것보다 적절한 메시지를 출력하고 다른 파일을 읽거나 임시 파일을 생성하는 것이 더 좋을 것
- 21_ErrorHandling/errorReturn/errorReturn.go 참고


[사용자 에러 반환]
func Sqrt(f float64) (float64, error) {
    if f < 0 {
        return 0, fmt.Errorf("제곱근은 양수여야 함. f:%g", f)   // f가 음수이면 에러 반환
    }
    return math.Sqrt(f), nil
}
- 위 코드는 fmt.Errorf() 함수를 사용해 에러를 반환. fmt 패키지의 Errorf() 함수를 사용하면 원하는 에러 메시지를 만들 수 있음
- 또는 'errors' 패키지의 New() 함수를 사용하여 error 생성 가능
    func New(text string) error
    ex) errors.New("에러 메시지")


[에러 타입]
error는 인터페이스로, 문자열을 반환하는 Error() 메서드로 구성되어 있음
    type error interface {
        Error() string
    }

즉 어떤 타입이든 문자열을 반환하는 Error() 메서드를 포함하고 있다면 에러로 사용할 수 있음
- 21_ErrorHandling/errorType/errorType.go 참고


[에러 랩핑]
에러를 감싸서 새로운 에러를 만들어야 하는 경우도 있다. 
ex) 파일에서 텍스트를 읽어서 특정 타입의 데이터로 변환하는 경우, 파일 읽기에서 발생하는 에러도 필요하지만, 
    텍스트의 몇 번쨰 줄의 몇 번째 칸에서 에러가 발생했는지도 알면 더 유용할 것
    파일 읽기 시 발생한 에러를 감싸고, 그 바깥에 줄과 칸 정보를 넣으면 됨
- 21_ErrorHandling/errorWrapping/errorWrapping.go 참고

------------------------------------------------------------------------------------------------------

[패닉(panic)]
패닉은 프로그램을 정상 진행시키기 어려운 상황을 만났을 때 프로그램 흐름을 '중지'시키는 기능
go 언어 내장 함수인 'panic()'으로 패닉 기능을 제공한다.

버그가 발생해 잘못된 메모리에 접근한다거나, 메모리가 부족하면 프로그램의 실행을 지속할 수 없다.
이럴 경우 프로그램을 강제 종료해서 문제를 빠르게 파악하는 편이 나을 수 있다. 
painc() 함수를 통해 문제 발생 시점에 프로그램을 바로 종료시켜서 문제 발생 시점을 바로 알 수 있다. 

panic() 함수가 자동으로 호출되는 예로는 슬라이스 길이를 넘어서 접근하면 Go 내부에서 패닉이 발생한다. 

panic() 내장 함수를 호출하고 인수로 에러 메시지를 입력하면, 
프로그램을 즉시 종료하고 에러 메시지를 출력하고 함수 호출 순서를 나타내는 '콜 스택(call stack)'을 표시한다. 

[패닉 생성]
- 패닉 함수 선언
    func panic(interface{})

위와 같이 panic() 내장 함수의 인수로 interface{} 타입 즉 모든 타입을 사용할 수 있다. 
- panic(42)
- panic("unreachable")
- panic(fmt.Errorf("This is error num:%d", num))
- panic(SomeType{SomeData})

[패닉 전파와 복구]
사용자에게 프로그램이 전달되고 난 뒤에는 문제가 발생하더라도 프로그램이 종료되는 대신 에러 메시지를 표시하고 북구를 시도하는 것이 더 나은 선택
사용자에게 프로그램이 배포된 이후 복구할 수 있는 패닉이라면 복구를 시도하는 것이 좋다.

panic은 호출 순서를 거슬러 올라가며 전파된다. 호출 과정이 main() -> f() -> g() 이고,
g() 함수에서 패닉이 발생하였다면 호출 순서를 거슬러 g() -> f() -> main() 함수로 전달된다. 
main() 함수에서까지 복구되지 않으면 그제서야 강제 종료된다. 

어느 단계에서든 패닉은 복구된 시점부터 프로그램이 계속된다. 'recover()' 함수를 호출하여 패닉을 복구할 수 있다. 
recover() 함수가 호출되는 시점에 패닉이 전파 중이면 panic 객체를 반환하고 그렇지 않으면 nil을 반환한다. 

[recover 결과]
- recover 함수 선언
    func recover() interface{}     // panic 객체를 반환함

panic 함수 인수로 interface{} 타입 즉 모든 타입이 가능
recover의 경우 interface{} 타입 반환, 따라서 recover()로 반환한 타입을 실제 사용하려면 타입 검사를 해야 함
    if r, ok := recover