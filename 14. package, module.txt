[패키지(package)]
- 패키지란 go 언어에서 코드를 묶는 가장 큰 단위
- (다른 언어에서는 네임스페이스 키워드를 통해 코드 영역을 분리하기도 하지만, go에서는 패키지를 사용)
- 함수로 코드 블록을, 구조체로 데이터를, 패키지로 함수와 구조체 그리고 그 외 코드를 묶는다.
- 프로그램은 하나의 main 패키지(main 함수 포함)와 여러 외부 패키지로 구성된다.


[main 패키지]
- 프로그램 시작점을 포함하는 특별한 패키지
- main 함수(프로그램 시작점)을 포함함


[그 외 패키지]
- 한 프로그램은 main 패키지 외 다수의 다른 패키지를 포함할 수 있음
    - fmt: 표준 입출력 패키지
    - crypto: 암호화 기능 패키지
    - net: 네트워크 기능 패키지
- import해서 사용함
- 표준 패키지: https://golang.org/pkg/


[경로가 있는 패키지]
import (
    "fmt"
    "math/rand"
)

func main() {
    fmt.PrintLn(rand.Int())
}
- 경로가 있는 패키지에 접근할 떄는 마지막 폴더명인 'rand'만 사용


[겹치는 패키지 문제 별칭으로 풀기]
import (
    "text/template"
    "html/template"
)
- 마지막 폴더명이 같아 결국 패키지명이 같다. 
- 별칭을 붙여 해결할 수 있음
import (
    "text/template"
    htemplate "html/template"
)


[사용하지 않는 패키지 포함]
- 패키지를 임포트하면 반드시 사용해야 함. 그러지 않으면 에러가 발생
- 패키지를 직접 사용하지 않지만 부가 효과를 얻고자 임포트하는 경우에는 '_' 밑줄을 패키지 앞에 붙인다.
import (
    "database/sql"
    _ "github.com/mattn/go-splite3"
)
- database/sql 패키지에서 splite3를 사용한다. 
- 하지만 직접 사용하지는 않기에 '_'를 붙인다.
- 위와 같은 경우 go-splite3의 init() 함수만을 호출하기 위해서 임포트 


[패키지 설치]
- import로 패키지를 포함하면 go build를 통해 빌드할 때 패키지를 찾아 포함하여 실행 파일을 생성함
- go에서 import 된 패키지는 아래 세 가지 방법을 찾음
    - 1. go 언어에서 기본 제공하는 패키지는 go 설치 경로에서 찾음
        go 설치 시 go에서 제공하는 기본 패키지들까지 같이 설치됨
        기본 패키지들은 go 설치 경로에 포함되어 있음
    - 2. 깃허브와 같은 외부 저장소에 저장된 패키지의 경우 외부 저장소에서 다운받아서 'GOPATH/pkg' 폴더에 설치함
        go 모듈에 정의된 패키지 버전에 맞게 다운로드하면 된다.
    - 3. 현재 모ㅗ듈 아래 위치한 패키지인지 검사. 
        현재 모듈 아래 위치한 패키지는 모듈이 존재하는 폴더 아래에 있는 패키지를 찾음.


----------------------------------------------------------------------------------------------------------------------------------


[Go 모듈]
- 모듈은 go 패키지들을 모아놓은 go 프로젝트 단위
- go build를 하려면 반드시 go 모듈 루트 폴더에 go.mod 파일이 존재해야 함
- go.mod 파일  
    - 모듈 이름
    - go 버전
    - 필요 외부 패키지 등 명시
- go build 시 go.mod와 외부 저장소 패키지 버전 정보를 담고 있는 'go.sum' 파일을 통해 외부 패키지와 모듈 내 패키지를 합쳐 실행 파일을 만듬
    
----------------------------------------------------------------------------------------------------------------------------------

[패키지 명과 패키지 외부 공개]
- 패키지 명은 모든 문자를 소문자로 할 것을 권장
- 패키지 전역으로 선언된 첫 글자가 대문자로 시작되는 모든 변수, 상수, 타입, 함수, 메서드는 패키지 외부로 공개됨
- 예시
    const (
        PI = 3.1415     // 공개되는 상수
        pi = 3.141516   // 공개되지 않는 상수
    )
    
    var ScreenSize int = 1000   // 공개되는 변수
    var screeSize int = 1000    // X

    func PuplicFunc() {..}      // 공개되는 함수
    func privateFunc() {..}     // X

    type MyInt  int         // 공개되는 별칭 타입
    type myString string    // X

    type MyStruct struct {  // 공개되는 구조체
        Age int         // 공개되는 구조체 필드 (공개되는 구조체 내부의 대문자 시작 필드는 공개)
        name string     // 공개되지 않는 구조체 필드 (공개되는 구조체라도 대문자로 시작하지 않는 필드는 공개되지 x)
    }

    func (m MyStruct) PublicMethod() { .. }     // 공개되는 메서드 (공개되는 구조체에 포함된 대문자 시작 메서드는 공개)
    func (m MyStruct) privateMethod() { .. }    // X 

    type myPrivateStruct struct {   // 공개되지 않는 구조체
        Age int         // 공개되지 않는 구조체 필드
        name string     //          "" 
    }

    func (m myPrivateStruct) PrivateMethod() { .. } // 공개되지 않는 메서드

----------------------------------------------------------------------------------------------------------------------------------

[패키지 초기화]
- 패키지를 임포트하면 벌어지는 일
    - 1) 컴파일러는 패키지 내 전역 변수를 초기화
    - 2) 패키지에 init() 함수가 있다면 호출하여 패키지를 초기화
        (init 함수는 입력 매개변수가 없고, 반환값도 없는 함수여야 함)
        (외부 패키지를 직접적으로 사용할 것은 아니지만, init() 함수 기능이 필요한 경우 '_' 별칭과 함께 임포트)
        
